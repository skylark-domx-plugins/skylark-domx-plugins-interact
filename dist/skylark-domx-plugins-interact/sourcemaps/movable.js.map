{"version":3,"sources":["movable.js"],"names":["define","langx","noder","datax","geom","eventer","styler","plugins","interact","Mouser","on","off","attr","removeAttr","pagePosition","addClass","height","Array","prototype","some","map","Movable","Plugin","inherit","klassName","pluginName","_construct","elm","options","updateWithMoveData","e","movable","self","moveEl","handleEl","call","this","overlayDiv","originalPos","handle","auto","constraints","doc","document","startingCallback","starting","startedCallback","started","movingCallback","moving","stoppedCallback","stopped","stop","remove","_handleEl","_mouser","cursor","docSize","getDocumentSize","ret","isPlainObject","preventDefault","button","relativePosition","size","css","createElement","position","top","left","width","zIndex","opacity","append","body","l","deltaX","t","deltaY","minX","maxX","minY","maxY","destroy","register"],"mappings":";;;;;;;AAAAA,QACI,sBACA,qBACA,oBACA,oBACA,uBACA,sBACA,4BACA,aACA,YACF,SAASC,EAAMC,EAAMC,EAAMC,EAAKC,EAAQC,EAAOC,EAAQC,EAASC,GACrDJ,EAAQK,GACPL,EAAQM,IACPR,EAAMS,KACAT,EAAMU,WACVT,EAAKU,aACHR,EAAOS,SACTX,EAAKY,OACPC,MAAMC,UAAUC,KACjBF,MAAMC,UAAUE,IAR1B,IAUIC,EAAUd,EAAQe,OAAOC,SACzBC,UAAW,UAEXC,WAAa,wBAGbC,WAAa,SAAUC,EAAKC,GAgBxB,SAASC,EAAmBC,GACxBA,EAAEC,QAAUC,EACZF,EAAEG,OAASN,EACXG,EAAEI,SAAWA,EAlBjB3B,EAAQe,OAAOJ,UAAUQ,WAAWS,KAAKC,KAAKT,EAAIC,GAsBlD,IAIIS,EAKAC,EATAN,EAAOI,KACPF,GAFJN,EAAUQ,KAAKR,SAEQW,QAAUZ,EAC7Ba,GAAwB,IAAjBZ,EAAQY,KACfC,EAAcb,EAAQa,YAEtBC,EAAMd,EAAQe,UAAYA,SAO1BC,EAAmBhB,EAAQiB,SAC3BC,EAAkBlB,EAAQmB,QAC1BC,EAAiBpB,EAAQqB,OACzBC,EAAkBtB,EAAQuB,QAsG1BC,EAAO,SAAStB,GAKZ5B,EAAMmD,OAAOhB,GAETa,GACAA,EAAgBpB,IAM5BM,KAAKkB,UAAYpB,EACjBE,KAAKmB,QAAU,IAAI9C,EAAO2B,KAAKkB,WAC3BP,QApHQ,SAASjB,GACb,IACI0B,EADAC,EAAUrD,EAAKsD,gBAAgBhB,GAMnC,GAFAb,EAAmBC,GAEfc,EAAkB,CAClB,IAAIe,EAAMf,EAAiBd,GAC3B,IAAa,IAAR6B,EACD,OACO1D,EAAM2D,cAAcD,KACvBA,EAAIlB,cACJA,EAAckB,EAAIlB,aAElBkB,EAAIZ,UACJD,EAAkBa,EAAIZ,SAEtBY,EAAIV,SACJD,EAAiBW,EAAIV,QAErBU,EAAIR,UACJD,EAAkBS,EAAIR,UAKlCrB,EAAE+B,iBAEW/B,EAAEgC,OAGfxB,EAAclC,EAAK2D,iBAAiBpC,GAC7BvB,EAAK4D,KAAKrC,GAGjB6B,EAASlD,EAAO2D,IAAI/B,EAAU,UAE9BG,EAAanC,EAAMgE,cAAc,OACjC5D,EAAO2D,IAAI5B,GACP8B,SAAU,WACVC,IAAK,EACLC,KAAM,EACNC,MAAOb,EAAQa,MACftD,OAAQyC,EAAQzC,OAChBuD,OAAQ,WACRC,QAAS,KACThB,OAAQA,IAEZtD,EAAMuE,OAAO/B,EAAIgC,KAAMrC,GAInBS,GACAA,EAAgBhB,IA+DxBmB,OA3DO,SAASnB,GAIZ,GAFAD,EAAmBC,GAEF,IAAbA,EAAEgC,OACF,OAAOV,EAAKtB,GAGjB,GAAIU,EAAM,CACL,IAAImC,EAAIrC,EAAY+B,KAAOvC,EAAE8C,OACzBC,EAAIvC,EAAY8B,IAAMtC,EAAEgD,OACxBrC,IAEIkC,EAAIlC,EAAYsC,OAChBJ,EAAIlC,EAAYsC,MAGhBJ,EAAIlC,EAAYuC,OAChBL,EAAIlC,EAAYuC,MAGhBH,EAAIpC,EAAYwC,OAChBJ,EAAIpC,EAAYwC,MAGhBJ,EAAIpC,EAAYyC,OAChBL,EAAIpC,EAAYyC,OAK5B9E,EAAK2D,iBAAiBpC,GAClB0C,KAAMM,EACNP,IAAKS,IAGT/C,EAAE+B,iBACEb,GACAA,EAAelB,IAsBvBqB,QAAUC,KAKlBC,OAAS,WACLjB,KAAKmB,QAAQ4B,UACb/C,KAAKmB,QAAU,QAOvB,OAFAhD,EAAQ6E,SAAS/D,EAAQ,WAElBb,EAASa,QAAUA","file":"../movable.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-data\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-eventer\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-plugins-base\",\r\n    \"./interact\",\r\n    \"./mouser\"\r\n],function(langx,noder,datax,geom,eventer,styler,plugins,interact,Mouser){\r\n    var on = eventer.on,\r\n        off = eventer.off,\r\n        attr = datax.attr,\r\n        removeAttr = datax.removeAttr,\r\n        offset = geom.pagePosition,\r\n        addClass = styler.addClass,\r\n        height = geom.height,\r\n        some = Array.prototype.some,\r\n        map = Array.prototype.map;\r\n\r\n    var Movable = plugins.Plugin.inherit({\r\n        klassName: \"Movable\",\r\n\r\n        pluginName : \"lark.interact.movable\",\r\n\r\n\r\n        _construct : function (elm, options) {\r\n            plugins.Plugin.prototype._construct.call(this,elm,options);\r\n\r\n            /*\r\n            function updateWithTouchData(e) {\r\n                var keys, i;\r\n\r\n                if (e.changedTouches) {\r\n                    keys = \"screenX screenY pageX pageY clientX clientY\".split(' ');\r\n                    for (i = 0; i < keys.length; i++) {\r\n                        e[keys[i]] = e.changedTouches[0][keys[i]];\r\n                    }\r\n                }\r\n            }\r\n            */\r\n\r\n            function updateWithMoveData(e) {\r\n                e.movable = self;\r\n                e.moveEl = elm;\r\n                e.handleEl = handleEl;\r\n            }\r\n\r\n            options = this.options;\r\n            var self = this,\r\n                handleEl = options.handle || elm,\r\n                auto = options.auto === false ? false : true,\r\n                constraints = options.constraints,\r\n                overlayDiv,\r\n                doc = options.document || document,\r\n                downButton,\r\n                start,\r\n                stop,\r\n                originalPos,\r\n                drag,\r\n                size,\r\n                startingCallback = options.starting,\r\n                startedCallback = options.started,\r\n                movingCallback = options.moving,\r\n                stoppedCallback = options.stopped,\r\n\r\n                start = function(e) {\r\n                    var docSize = geom.getDocumentSize(doc),\r\n                        cursor;\r\n\r\n                    ///updateWithTouchData(e);\r\n                    updateWithMoveData(e);\r\n\r\n                    if (startingCallback) {\r\n                        var ret = startingCallback(e)\r\n                        if ( ret === false) {\r\n                            return;\r\n                        } else if (langx.isPlainObject(ret)) {\r\n                            if (ret.constraints) {\r\n                                constraints = ret.constraints;\r\n                            }\r\n                            if (ret.started) {\r\n                                startedCallback = ret.started;\r\n                            }\r\n                            if (ret.moving) {\r\n                                movingCallback = ret.moving;\r\n                            }                            \r\n                            if (ret.stopped) {\r\n                                stoppedCallback = ret.stopped;\r\n                            }     \r\n                        }\r\n                    }\r\n\r\n                    e.preventDefault();\r\n\r\n                    downButton = e.button;\r\n \r\n\r\n                    originalPos = geom.relativePosition(elm);\r\n                    size = geom.size(elm);\r\n\r\n                    // Grab cursor from handle so we can place it on overlay\r\n                    cursor = styler.css(handleEl, \"cursor\");\r\n\r\n                    overlayDiv = noder.createElement(\"div\");\r\n                    styler.css(overlayDiv, {\r\n                        position: \"absolute\",\r\n                        top: 0,\r\n                        left: 0,\r\n                        width: docSize.width,\r\n                        height: docSize.height,\r\n                        zIndex: 0x7FFFFFFF,\r\n                        opacity: 0.0001,\r\n                        cursor: cursor\r\n                    });\r\n                    noder.append(doc.body, overlayDiv);\r\n\r\n                    ////eventer.on(doc, \"mousemove touchmove\", move).on(doc, \"mouseup touchend\", stop);\r\n\r\n                    if (startedCallback) {\r\n                        startedCallback(e);\r\n                    }\r\n                },\r\n\r\n                move = function(e) {\r\n                    ///updateWithTouchData(e);\r\n                    updateWithMoveData(e);\r\n\r\n                    if (e.button !== 0) {\r\n                        return stop(e);\r\n                    }\r\n\r\n                   if (auto) {\r\n                        var l = originalPos.left + e.deltaX,\r\n                            t = originalPos.top + e.deltaY;\r\n                        if (constraints) {\r\n\r\n                            if (l < constraints.minX) {\r\n                                l = constraints.minX;\r\n                            }\r\n\r\n                            if (l > constraints.maxX) {\r\n                                l = constraints.maxX;\r\n                            }\r\n\r\n                            if (t < constraints.minY) {\r\n                                t = constraints.minY;\r\n                            }\r\n\r\n                            if (t > constraints.maxY) {\r\n                                t = constraints.maxY;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    geom.relativePosition(elm, {\r\n                        left: l,\r\n                        top: t\r\n                    })\r\n\r\n                    e.preventDefault();\r\n                    if (movingCallback) {\r\n                        movingCallback(e);\r\n                    }\r\n                },\r\n\r\n                stop = function(e) {\r\n                    ///updateWithTouchData(e);\r\n\r\n                    ///eventer.off(doc, \"mousemove touchmove\", move).off(doc, \"mouseup touchend\", stop);\r\n\r\n                    noder.remove(overlayDiv);\r\n\r\n                    if (stoppedCallback) {\r\n                        stoppedCallback(e);\r\n                    }\r\n                };\r\n\r\n            ///eventer.on(handleEl, \"mousedown touchstart\", start);\r\n\r\n            this._handleEl = handleEl;\r\n            this._mouser = new Mouser(this._handleEl,{\r\n                started : start,\r\n                moving : move,\r\n                stopped : stop\r\n            })\r\n\r\n        },\r\n\r\n        remove : function() {\r\n            this._mouser.destroy();\r\n            this._mouser = null;\r\n            ///eventer.off(this._handleEl);\r\n        }\r\n    });\r\n\r\n    plugins.register(Movable,\"movable\");\r\n\r\n    return interact.Movable = Movable;\r\n});\r\n"]}